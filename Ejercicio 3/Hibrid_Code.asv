
%% --------------Control Hibrido----------------------------

clear all;
close all;
clc;


%Variables Control de Fuerza:
global rob fd Kenv n kpf kvf d_pared rob2
n = [1/sqrt(2); 1/sqrt(2)];



% ========== DEFINICIÓN DEL ROBOT ==========
% Definicion de Links
L(1) = Link('revolute', 'd', 0, 'a', 1, 'alpha', 0);
L(2) = Link('revolute', 'd', 0, 'a', 1, 'alpha', 0);

L(1).m = 1;                     % Masa (1 kg)
L(1).r = [L(1).a, 0, 0];        % Centro de masa en la punta (x=a)
L(1).I = zeros(3,3);            % Inercia de una masa puntual es CERO

L(2).m = 1;
L(2).r = [L(2).a, 0, 0];        % Centro de masa en la punta (x=a)
L(2).I = zeros(3,3);            % Inercia de una masa puntual es CERO

L(1).Tc = 1;                    % Fricción de Coulomb
L(2).Tc = 1;                    % Fricción de Coulomb

g = [0 0 -10]; 




% Crear robot nominal y perturbado
rob = SerialLink(L, 'name', '2R Robot', 'gravity', g); 
rob2 = rob.perturb(0.8);  % 80% de perturbación

% ========== DEFINICIÓN DE TRAYECTORIA ==========
T1 = transl(1.5, 0.5, 0) * trotz(-pi/2);  % Posición cartesiana inicial 
T2 = transl(0.5, 1.5, 0) * trotz(pi/2);    % Posición cartesiana final
t = [0:0.02:5]';                       % Tiempo de trayectoria propuesto

[s, sd, sdd] = tpoly(0, 1, t, 0, 0);

s(s < 0) = 0;
s(s > 1) = 1;

Tcart = ctraj(T1, T2, s);

X = squeeze(Tcart(1, 4, :));
Y = squeeze(Tcart(2, 4, :));

P1_vec = T1(1:3, 4); % [1; -1; 0]
P2_vec = T2(1:3, 4); % [1; 1; 0]
P_delta = P2_vec - P1_vec; % [0; 2; 0]

Vel_cart = P_delta * sd'; % Resultado es [3xN]
Acc_cart = P_delta * sdd'; % Resultado es [3xN]

X_d = Vel_cart(1, :)';
Y_d = Vel_cart(2, :)';

X_dd = Acc_cart(1, :)';
Y_dd = Acc_cart(2, :)';

if isrow(t)
    t = t';
end

Posicion_Cartesiana = [t, X, Y];
Velocidad_Cartesiana = [t, X_d, Y_d];
Aceleracion_Cartesiana = [t, X_dd, Y_dd];

% ========== CINEMÁTICA INVERSA ==========
q_nominal = [0, 0]; % Conjetura inicial de ángulos (q1=0, q2=0)
N = length(t); 
qd_deseado = zeros(N, rob.n); % rob.n = 2 DOF

% Definición de la Máscara para un Robot 2R plano:
% [X, Y, Z, Roll, Pitch, Yaw]. Solo nos importan X e Y.
mascara = [1 1 0 0 0 0]; 

for i = 1:N
    T_i = Tcart(:, :, i);
    
    q_i = rob.ikine(T_i, 'q0', q_nominal, 'ru', 'mask', mascara);
    
    if ~isempty(q_i) 
        qd_deseado(i, :) = q_i;
        q_nominal = q_i;
    else
        disp(['Advertencia: ikine no encontró solución en el paso ', num2str(i)]);
        qd_deseado(i, :) = qd_deseado(max(1, i-1), :); 
    end
end


%% CONDICIONES INICIALES

% Posición articular inicial (radianes)
q_inicial = [1.93; -1.143];

% Velocidades articulares iniciales (en reposo)
qd_inicial = [0; 0];

% Aceleraciones articulares iniciales
qdd_inicial = [0; 0];

% Verificar la posición cartesiana inicial del efector
T_inicial = rob.fkine(q_inicial);
pos_inicial = T_inicial.t;


% Calcular distancia a la pared
d_inicial = d_pared - (n(1)*pos_inicial(1) + n(2)*pos_inicial(2));
fprintf('\nDistancia inicial a la pared: %.4f m\n', d_inicial);

if d_inicial < 0
    fprintf('  ⚠️  El robot YA está en contacto (penetración: %.4f m)\n', -d_inicial);
elseif d_inicial < 0.1
    fprintf('  ⚠️  El robot está MUY cerca de la pared\n');
else
    fprintf('  ✓ El robot está antes de la pared\n');
end

%% TRAYECTORIA DE ACERCAMIENTO SEGURA

t = [0:0.02:5]'; % Tiempo de simulación propuesto
if isrow(t); t = t'; end
N = length(t);

% Puntos Cartesianos para la Trayectoria
P_start = pos_inicial(1:2); % Partir desde la posición inicial real
P_contacto = [1; 1];
P_penetracion = P_contacto + 0.5 * n(1:2); % Intenta penetrar 0.5m más allá

% Matrices de Transformación
T1 = transl([P_start; 0]') * trotz(0); 
T2 = transl([P_penetracion; 0]') * trotz(pi/4); 

% Generación de la Trayectoria (incluye X, Xd, Xdd)
[s, sd, sdd] = tpoly(0, 1, t, 0, 0); % Escalado polinómico
Tcart = ctraj(T1, T2, s); 

% Extracción de Posición, Velocidad y Aceleración Cartesianas
X = squeeze(Tcart(1, 4, :));
Y = squeeze(Tcart(2, 4, :));

P_delta = P_penetracion - P_start; % Solo X e Y
Vel_cart = P_delta * sd';
Acc_cart = P_delta * sdd';

% Formato para el bloque From Workspace de Simulink ([Tiempo, X, Y])
Posicion_Cartesiana = [t, X, Y];
Velocidad_Cartesiana = [t, Vel_cart(1,:)', Vel_cart(2,:)']; 
Aceleracion_Cartesiana = [t, Acc_cart(1,:)', Acc_cart(2,:)']; 

X_d = Vel_cart(1, :)';
Y_d = Vel_cart(2, :)';

X_dd = Acc_cart(1, :)';
Y_dd = Acc_cart(2, :)';

num_columnas = length(t);

% Fuerza deseada constante en el tiempo
fila_10 = (10 * ones(1, num_columnas))'; % [10, 10, 10, ...]
fila_0 = (zeros(1, num_columnas))';      % [0, 0, 0, ...]

Fd = [t, fila_10, fila_0];


if isstruct(out.Q_out_f)
    q_data = out.Q_out_f.Data;  % [N x 2]
else
    q_data = out.Q_out_f;
end